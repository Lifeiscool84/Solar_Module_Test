#include <Wire.h>
#include <hp_BH1750.h>
#include <SPI.h>
#include <SD.h>
#include <SparkFun_RV8803.h>
#include <SparkFun_u-blox_GNSS_Arduino_Library.h>

// BH1750 Light Sensor
hp_BH1750 lightMeter; // Uses default I2C address 0x23

// RV8803 Real-Time Clock
RV8803 rtc;

// GNSS Module
SFE_UBLOX_GNSS myGNSS;
bool isGNSSFixed = false;

// SD Card Configuration
const int chipSelect = 8; // SD card CS pin
char LOG_FILENAME[20] = "solar.csv"; // Changed to variable to allow filename updates
bool sdCardReady = false;
unsigned long lastLogTime = 0;
const unsigned long LOG_INTERVAL = 1000; // Log every 1 second (1000ms)

// Central Time Zone Configuration
// Central Standard Time (CST) = UTC-6 hours = -24 quarter hours
// Central Daylight Time (CDT) = UTC-5 hours = -20 quarter hours
// Default to CDT to match current local time requirement
int8_t currentTimeZone = -20; // Start with CDT (-5 hours in quarter hours)

// GNSS Time Synchronization Configuration
bool gnssTimeSyncEnabled = true;           // Enable automatic GNSS time sync
unsigned long lastGnssTimeSync = 0;        // Last time we synced with GNSS
const unsigned long GNSS_SYNC_INTERVAL = 2UL * 60UL * 60UL * 1000UL; // 2 hours in milliseconds
bool startupGnssTimeSyncDone = false;      // Track if we did startup sync

// Define I2C addresses for INA228 sensors
const uint8_t INA_SOLAR_ADDR = 0x40;
const uint8_t INA_BATTERY_ADDR = 0x44; // Note: Your original serial print said 0x42 for battery
const uint8_t INA_LOAD_ADDR = 0x41;

// INA228 register addresses
const uint8_t INA228_REG_CONFIG = 0x00;
const uint8_t INA228_REG_ADCCFG = 0x01; // ADC_CONFIG Register
const uint8_t INA228_REG_SHUNTCAL = 0x02;
const uint8_t INA228_REG_VSHUNT = 0x04;
const uint8_t INA228_REG_VBUS = 0x05;
const uint8_t INA228_REG_DIETEMP = 0x06; // Die Temperature Register
const uint8_t INA228_REG_CURRENT = 0x07;
const uint8_t INA228_REG_POWER = 0x08;
// const uint8_t INA228_REG_ENERGY = 0x09; // Not used
// const uint8_t INA228_REG_CHARGE = 0x0A; // Not used
// const uint8_t INA228_REG_DIAGALRT = 0x0B; // Not used
const uint8_t INA228_REG_MFG_UID = 0x3E;
const uint8_t INA228_REG_DEVICE_ID = 0x3F; // Corrected name

// Global Shunt Resistor Value (used for Vshunt/Rshunt calculation in loop)
const float SHUNT_OHMS_PROGRAMMED = 0.015f;

// Battery-specific calibration values (measured with 4-wire method)
// IMPORTANT: Battery monitoring uses direct calculation approach instead of chip calibration
// Effective resistance accounts for parasitic resistance in PCB traces and connections
// Current is calculated as: I = V_shunt / R_effective
// Power preserves sign: P = V * I (negative = charging, positive = discharging)
const float EFFECTIVE_SHUNT_OHMS_BATTERY = 0.0177186f; // Effective resistance including parasitic resistance
const float MAX_CURRENT_BATTERY = 5.0f; // Maximum expected current for battery monitoring

// Calibration and scaling variables
float solar_current_lsb = 0.0f;
float battery_current_lsb = 0.0f;
float load_current_lsb = 0.0f;

// Data structure for logging
struct SensorData {
  unsigned long timestamp_ms; // Keep millis for timing
  char date_str[12];          // Date in YYYY-MM-DD format
  char time_str[10];          // Time in HH:MM:SS military format (24-hour)
  float lux;
  // GPS coordinates
  float latitude;
  float longitude;
  bool gps_fix;
  int gps_satellites;
  // Solar sensor data
  float solar_voltage;
  float solar_current;
  float solar_power;
  float solar_temperature;
  // Battery sensor data
  float battery_voltage;
  float battery_current;
  float battery_power;
  float battery_temperature;
  // Load sensor data
  float load_voltage;
  float load_current;
  float load_power;
  float load_temperature;
};

// Function prototypes
float initINA228(uint8_t address, const char* sensorName, float shuntOhms, float maxCurrent);
void inspectINA228Registers(uint8_t address, const char* sensorName);
float readBusVoltage(uint8_t address, uint32_t& rawRegValue, uint32_t& shiftedRegValue);
float readShuntVoltage(uint8_t address, int32_t& rawRegValue, int32_t& shiftedRegValue);
float readCurrent(uint8_t address, float current_lsb_value, int32_t& rawRegValue, int32_t& shiftedRegValue);
float readPower(uint8_t address, float current_lsb_value, uint32_t& rawRegValue);
float readTemperature(uint8_t address, uint16_t& rawRegValue);
uint32_t readRegister(uint8_t address, uint8_t reg, uint8_t numBytes);
uint16_t readRegister16(uint8_t address, uint8_t reg); // Helper for 16-bit registers
bool initSDCard();
void createCSVHeader();
void logDataToSD(const SensorData& data);
void listExistingLogFiles(); // New function to list solar log files
SensorData readAllSensors();
// RTC Functions
bool initRTC();
void handleSerialTimeCommands();
void printRTCStatus();
void setTimeZone(bool isDST);
void updateRTCTimestamp(SensorData& data);
// GNSS Functions
bool initGNSS();
void readGNSSData(SensorData& data);
bool validateGnssData();
// GNSS Time Sync Functions
bool syncRTCWithGNSS();
bool syncRTCWithGNSSLocal();
void checkPeriodicGNSSTimeSync();
// handleTimeAdjustmentCommands() function removed
// Enhanced menu functions for RTC adjustment
void showRealTimeDisplay();
void showEnhancedRealTimeDisplay();
String readSerialCommand_String();
void executeTimeCommand(String command);
void adjustTimeSeconds(int seconds);
void toggleTimeZone();

// ARTEMIS NANO SERIAL FIX: The Artemis Nano has known issues with Serial.available()
// returning 0 even when data is present. This is a hardware/driver issue.
// Solution: Use a polling approach with direct register access
bool serialDebugMode = true; // START WITH DEBUG ENABLED TO DIAGNOSE ISSUES

// ARTEMIS NANO WORKAROUND: Use both Serial and Serial1 for input
// This is a known hardware issue - Serial RX may not work but Serial1 might
char readSerialCommand() {
  static unsigned long lastCheck = 0;
  
  // Force a small delay between reads to allow hardware to update
  if (millis() - lastCheck < 5) {
    return 0;
  }
  lastCheck = millis();
  
  // Try both Serial and Serial1 for input (Artemis Nano workaround)
  for (int attempt = 0; attempt < 3; attempt++) {
    // First try Serial (main USB)
    int available = Serial.available();
    if (available > 0) {
      char receivedChar = Serial.read();
      
      if (serialDebugMode) {
        Serial.print(F("DEBUG: Serial - Available: "));
        Serial.print(available);
        Serial.print(F(" - Read char '"));
        if (receivedChar >= 32 && receivedChar <= 126) {
          Serial.print(receivedChar);
        } else {
          Serial.print(F("["));
          Serial.print((int)receivedChar);
          Serial.print(F("]"));
        }
        Serial.println(F("'"));
      }
      
      if (receivedChar >= 32 && receivedChar <= 126) {
        return receivedChar;
      }
    }
    
    // ARTEMIS NANO: Serial1 temporarily disabled to avoid compilation issues
    // Will implement hardware fix through variant.cpp instead
    /*
    if (Serial1.available() > 0) {
      char receivedChar = Serial1.read();
      
      if (serialDebugMode) {
        Serial.print(F("DEBUG: Serial1 - Read char '"));
        if (receivedChar >= 32 && receivedChar <= 126) {
          Serial.print(receivedChar);
        } else {
          Serial.print(F("["));
          Serial.print((int)receivedChar);
          Serial.print(F("]"));
        }
        Serial.println(F("'"));
      }
      
      if (receivedChar >= 32 && receivedChar <= 126) {
        return receivedChar;
      }
    }
    */
    
    // Small delay between attempts
    if (attempt < 2) {
      delayMicroseconds(200);
    }
  }
  
  return 0; // No valid character available
}

void setup() {
  // CRITICAL FIX: Initialize serial without blocking on Artemis Nano
  // This is a known issue with Artemis boards where Serial.begin() can hang
  // See: https://community.sparkfun.com/t/problems-with-serial-begin/40985
  
  // First, ensure serial pins are in correct state
  pinMode(0, INPUT_PULLUP);  // RX pin
  pinMode(1, OUTPUT);        // TX pin
  digitalWrite(1, HIGH);     // TX idle state
  delay(100);               // Let hardware stabilize
  
  Serial.begin(115200);
  Serial.flush();           // Clear any garbage
  
  // ARTEMIS NANO WORKAROUND: Temporarily disabled Serial1 to avoid compilation issues
  // Serial1.begin(115200);
  // Serial1.flush();
  
  // Non-blocking wait with timeout
  unsigned long serialStart = millis();
  while (millis() - serialStart < 3000) {
    if (Serial) break;
    delay(10);
  }

  Serial.println(F("Starting Solar Panel Monitoring System..."));
  Wire.begin();

  // Initialize RTC first
  Serial.print(F("Initializing RTC..."));
  if (initRTC()) {
    Serial.println(F(" RTC online!"));
    
    // Check if RTC has valid time - only set to compiler time if needed
    if (rtc.updateTime()) {
      // Check if time is reasonable (not default/reset values)
      uint16_t year = rtc.getYear();
      uint8_t month = rtc.getMonth();
      uint8_t day = rtc.getDate();
      uint8_t hour = rtc.getHours();
      uint8_t minute = rtc.getMinutes();
      uint8_t second = rtc.getSeconds();
      
      Serial.print(F("Current RTC reading: "));
      Serial.print(year); Serial.print(F("-"));
      Serial.print(month); Serial.print(F("-"));
      Serial.print(day); Serial.print(F(" "));
      Serial.print(hour); Serial.print(F(":"));
      Serial.print(minute); Serial.print(F(":"));
      Serial.println(second);
      
      // Check for obviously invalid time (year < 2020 or year > current+1, or all zeros)
      // Note: Compiler might be set to wrong date, so we'll be more selective
      if (year < 2020 || year > 2026 || 
          (year == 2000 && month == 1 && day == 1 && hour == 0 && minute == 0 && second == 0)) {
        Serial.println(F("RTC time appears invalid (out of reasonable range) - setting to compiler time..."));
        if (rtc.setToCompilerTime() == false) {
          Serial.println(F("Failed to set compiler time!"));
        } else {
          Serial.println(F("RTC set to compiler time successfully!"));
        }
      } else {
        Serial.println(F("RTC has valid time - keeping existing time"));
        Serial.println(F("IMPORTANT: If this time is wrong, use the time adjustment commands (+/-) to correct it"));
      }
    } else {
      Serial.println(F("RTC communication failed - attempting compiler time set..."));
      rtc.setToCompilerTime();
    }
    
    printRTCStatus();
    
    // Improved serial monitor detection - test if there's actually a monitor connected
    // Check for actual serial monitor presence with a brief test
    bool hasActiveSerialMonitor = false;
    if (Serial) {
      Serial.println(F("\nTesting for active serial monitor..."));
      Serial.flush();
      delay(100); // Give time for data to be sent
      
      // If Serial shows as connected, assume there's a monitor for now
      // The timeout mechanism in showEnhancedRealTimeDisplay will handle false positives
      hasActiveSerialMonitor = true;
    }
    
    // Auto-start real-time display if Serial monitor appears to be connected
    // If no Serial connection, skip time adjustment and go straight to measurements
    if (hasActiveSerialMonitor) {
      Serial.println(F("\n=== Real-Time Clock Adjustment ==="));
      Serial.println(F("Commands during real-time display:"));
      Serial.println(F("  + or +N  - Add 1 or N seconds (type + then digits then Enter)"));
      Serial.println(F("  - or -N  - Subtract 1 or N seconds (type - then digits then Enter)"));
      Serial.println(F("  z        - Toggle timezone (CST/CDT)"));
      Serial.println(F("  d        - Toggle debug mode"));
      Serial.println(F("  c        - Continue to main program"));
      Serial.println(F("Starting real-time display (with auto-timeout)..."));
      delay(1000);
      
      // Start real-time display with timeout protection
      showEnhancedRealTimeDisplay();
    } else {
      Serial.println(F("No serial monitor detected - skipping time adjustment"));
      Serial.println(F("Continuing directly to sensor measurements..."));
    }
  } else {
    Serial.println(F(" Failed to initialize!"));
  }

  // Initialize GNSS
  Serial.print(F("Initializing GNSS..."));
  if (initGNSS()) {
    Serial.println(F(" GNSS online!"));
    
    // Enhanced startup GNSS time sync with retry mechanism
    if (gnssTimeSyncEnabled) {
      Serial.println(F("GNSS Time Sync: Checking for immediate GPS fix..."));
      
      // First attempt: Check if GPS already has a fix (rare but possible)
      if (syncRTCWithGNSSLocal()) {
        Serial.println(F("GNSS Time Sync: Immediate sync successful!"));
        startupGnssTimeSyncDone = true;
        lastGnssTimeSync = millis();
      } else {
        Serial.println(F("GNSS Time Sync: No immediate fix available."));
        Serial.println(F("GPS modules typically need 30-90 seconds for cold start."));
        Serial.println(F("Time sync will be attempted automatically when GPS gets a fix."));
        Serial.println(F("Manual sync available with 'g' command during real-time display."));
        
        // For better debugging, show current GPS status
        SensorData tempData;
        readGNSSData(tempData);
        Serial.print(F("Current GPS status: "));
        Serial.print(tempData.gps_satellites);
        Serial.println(F(" satellites visible"));
      }
    }
  } else {
    Serial.println(F(" GNSS initialization failed!"));
  }

  // Initialize SD Card
  Serial.print(F("Initializing SD card..."));
  if (initSDCard()) {
    sdCardReady = true;
    listExistingLogFiles(); // Show existing files for reference
    createCSVHeader();
    Serial.println(F("SD Card logging enabled."));
  } else {
    Serial.println(F("SD Card logging disabled - continuing with serial output only."));
  }

  if (lightMeter.begin(BH1750_TO_GROUND)) {
    Serial.println(F("BH1750 Light Sensor Initialized."));
    lightMeter.start();
  } else {
    Serial.println(F("Error initializing BH1750 Light Sensor!"));
  }

  Serial.println(F("\nInitializing INA228 sensors and inspecting registers..."));

  solar_current_lsb = initINA228(INA_SOLAR_ADDR, "Solar", SHUNT_OHMS_PROGRAMMED, 5.0f);
  if (solar_current_lsb > 0.0f) {
    Serial.print(F("INA228 Solar (0x40) Init OK. Current LSB (A/bit): ")); Serial.println(solar_current_lsb, 10);
    inspectINA228Registers(INA_SOLAR_ADDR, "Solar");
  } else {
    Serial.println(F("Failed to initialize INA228 Solar Monitor (0x40)"));
  }
battery_current_lsb = initINA228(
    INA_BATTERY_ADDR,
    "Battery",
    EFFECTIVE_SHUNT_OHMS_BATTERY, // Use the calculated effective shunt resistance
    MAX_CURRENT_BATTERY);
  if (battery_current_lsb > 0.0f) {
    Serial.print(F("INA228 Battery (0x44) Init OK. Current LSB (A/bit): ")); Serial.println(battery_current_lsb, 10);
    inspectINA228Registers(INA_BATTERY_ADDR, "Battery");
  } else {
    Serial.println(F("Failed to initialize INA228 Battery Monitor (0x44)"));
  }

  load_current_lsb = initINA228(INA_LOAD_ADDR, "Load", SHUNT_OHMS_PROGRAMMED, 5.0f);
  if (load_current_lsb > 0.0f) {
    Serial.print(F("INA228 Load (0x41) Init OK. Current LSB (A/bit): ")); Serial.println(load_current_lsb, 10);
    inspectINA228Registers(INA_LOAD_ADDR, "Load");
  } else {
    Serial.println(F("Failed to initialize INA228 Load Monitor (0x41)"));
  }
  
  Serial.println(F("\nSensor initialization complete. Starting measurements."));
  Serial.println(F("Logging data every 1 second..."));
  if (sdCardReady) {
    Serial.println(F("SD Card Status: READY"));
  } else {
    Serial.println(F("SD Card Status: FAILED"));
  }
  Serial.println(F("--------------------------------------------------"));
  Serial.println(F("SETUP COMPLETE - Entering main data collection loop"));
  Serial.println(F("Data collection will run regardless of serial connection status"));
  Serial.println(F("\nDATA FORMAT: Clean display updates every second"));
  Serial.println(F("Battery Power: Negative=Charging, Positive=Discharging"));
  Serial.flush(); // Ensure all setup messages are sent
  lastLogTime = millis();
}

void loop() {
  unsigned long currentTime = millis();
  
  // Log data every second
  if (currentTime - lastLogTime >= LOG_INTERVAL) {
    SensorData data = readAllSensors();
    
    // Enhanced GNSS time sync check with detailed debugging
    if (gnssTimeSyncEnabled && data.gps_fix) {
      // Calculate time since last sync
      unsigned long timeSinceLastSync = currentTime - lastGnssTimeSync;
      
      // Debug output for sync timing (show every 30 seconds when GPS is fixed)
      static unsigned long lastSyncDebug = 0;
      if (currentTime - lastSyncDebug > 30000) { // Every 30 seconds
        Serial.print(F("GNSS Sync Debug: GPS Fix="));
        Serial.print(data.gps_fix ? "YES" : "NO");
        Serial.print(F(", Sats="));
        Serial.print(data.gps_satellites);
        Serial.print(F(", Time since last sync="));
        Serial.print(timeSinceLastSync / 1000);
        Serial.print(F("s, Interval="));
        Serial.print(GNSS_SYNC_INTERVAL / 1000);
        Serial.println(F("s"));
        lastSyncDebug = currentTime;
      }
      
      // Check if it's time for sync
      if (timeSinceLastSync >= GNSS_SYNC_INTERVAL) {
        Serial.print(F("GNSS Sync Trigger: Time since last sync ("));
        Serial.print(timeSinceLastSync / 1000);
        Serial.print(F("s) >= interval ("));
        Serial.print(GNSS_SYNC_INTERVAL / 1000);
        Serial.println(F("s)"));
        checkPeriodicGNSSTimeSync();
      }
      
      // Special case: If this is the first GPS fix and no sync has been done yet
      if (lastGnssTimeSync == 0 && !startupGnssTimeSyncDone) {
        Serial.println(F("GNSS Sync Trigger: First GPS fix detected, attempting immediate sync..."));
        if (syncRTCWithGNSSLocal()) {
          Serial.println(F("First GPS sync successful!"));
          lastGnssTimeSync = millis();
          startupGnssTimeSyncDone = true;
        } else {
          Serial.println(F("First GPS sync failed - will retry on next interval"));
        }
      }
    } else if (gnssTimeSyncEnabled && !data.gps_fix) {
      // Show why sync is not happening (every minute when no GPS)
      static unsigned long lastNoGpsDebug = 0;
      if (currentTime - lastNoGpsDebug > 60000) { // Every 60 seconds
        Serial.print(F("GNSS Sync Status: No GPS fix ("));
        Serial.print(data.gps_satellites);
        Serial.println(F(" satellites) - sync not possible"));
        lastNoGpsDebug = currentTime;
      }
    }
    
    // Debug output to show data collection is running (even without serial monitor)
    static unsigned long debugCounter = 0;
    debugCounter++;
    
    // Print to serial for monitoring (only if connected)
    if (Serial) {
      // Print simplified data format every reading
      Serial.print(data.time_str); Serial.print(F(" | "));
      Serial.print(F("GPS:")); Serial.print(data.gps_fix ? F("YES") : F("NO"));
      Serial.print(F("(")); Serial.print(data.gps_satellites); Serial.print(F(") | "));
      
      // Solar: voltage/current/power
      Serial.print(F("Solar: ")); Serial.print(data.solar_voltage, 2); Serial.print(F("V/"));
      Serial.print(data.solar_current, 1); Serial.print(F("mA/"));
      Serial.print(data.solar_power, 1); Serial.print(F("mW | "));
      
      // Battery: voltage/current/power + status
      Serial.print(F("Battery: ")); Serial.print(data.battery_voltage, 2); Serial.print(F("V/"));
      Serial.print(data.battery_current, 1); Serial.print(F("mA/"));
      Serial.print(data.battery_power, 1); Serial.print(F("mW "));
      if (data.battery_current > 0.5) {
        Serial.print(F("(DISCHARGING)"));
      } else if (data.battery_current < -0.5) {
        Serial.print(F("(CHARGING)"));
      } else {
        Serial.print(F("(IDLE)"));
      }
      Serial.print(F(" | "));
      
      // Load: voltage/current/power
      Serial.print(F("Load: ")); Serial.print(data.load_voltage, 2); Serial.print(F("V/"));
      Serial.print(data.load_current, 1); Serial.print(F("mA/"));
      Serial.print(data.load_power, 1); Serial.print(F("mW"));
      
      Serial.println(); // End of line
      
      // Show periodic status confirmation (every 60 seconds)
      if (debugCounter % 60 == 1) {
        Serial.print(F("STATUS: Reading #"));
        Serial.print(debugCounter);
        Serial.print(F(" | Date: "));
        Serial.print(data.date_str);
        if (data.gps_fix) {
          Serial.print(F(" | GPS: "));
          Serial.print(data.latitude, 6);
          Serial.print(F(","));
          Serial.print(data.longitude, 6);
        }
        Serial.println();
      }
      
      // Temperature warnings (only for critical temperatures)
      float maxTemp = data.solar_temperature;
      if (data.battery_temperature > maxTemp) maxTemp = data.battery_temperature;
      if (data.load_temperature > maxTemp) maxTemp = data.load_temperature;
      
      float minTemp = data.solar_temperature;
      if (data.battery_temperature < minTemp) minTemp = data.battery_temperature;
      if (data.load_temperature < minTemp) minTemp = data.load_temperature;
      
      if (maxTemp > 60.0) {
        Serial.print(F("WARNING: High temperature detected: ")); 
        Serial.print(maxTemp, 1); Serial.println(F("°C"));
      }
      if (minTemp < -10.0) {
        Serial.print(F("WARNING: Low temperature detected: ")); 
        Serial.print(minTemp, 1); Serial.println(F("°C"));
      }
      
      // Power calculation verification (every 60 readings)
      if (debugCounter % 60 == 1) {
        Serial.println(F("POWER VERIFICATION: V*I vs Sensor"));
        Serial.print(F("Solar: "));
        Serial.print(data.solar_voltage * data.solar_current, 1);
        Serial.print(F(" vs "));
        Serial.print(data.solar_power, 1);
        Serial.print(F(" mW | Battery: "));
        Serial.print(data.battery_voltage * data.battery_current, 1);
        Serial.print(F(" vs "));
        Serial.print(data.battery_power, 1);
        Serial.print(F(" mW | Load: "));
        Serial.print(data.load_voltage * data.load_current, 1);
        Serial.print(F(" vs "));
        Serial.print(data.load_power, 1);
        Serial.println(F(" mW"));
      }
    }
    
    // ALWAYS attempt to log to SD card, regardless of serial connection
    if (sdCardReady) {
      logDataToSD(data);
      
      // Periodic SD card status confirmation (every 30 seconds)
      if (debugCounter % 30 == 1) {
        if (Serial) {
          Serial.print(F("SD CARD STATUS: ACTIVE - Logging to "));
          Serial.println(LOG_FILENAME);
        }
      }
    } else {
      // Try to reinitialize SD card periodically if it failed
      static unsigned long lastSDRetry = 0;
      if (currentTime - lastSDRetry > 30000) { // Retry every 30 seconds
        if (Serial) Serial.println(F("Attempting SD card re-initialization..."));
        if (initSDCard()) {
          sdCardReady = true;
          createCSVHeader();
          if (Serial) Serial.println(F("SD card re-initialized successfully!"));
        } else {
          if (Serial) Serial.println(F("SD card re-initialization failed"));
        }
        lastSDRetry = currentTime;
      }
      
      // Show SD card failure status periodically
      if (debugCounter % 60 == 1) { // Every 60 seconds
        if (Serial) Serial.println(F("SD CARD STATUS: FAILED - Data not being logged to file"));
      }
    }
    
    lastLogTime = currentTime;
  }
  
  // Short delay to prevent excessive CPU usage
  delay(50);
}

bool initSDCard() {
  Serial.print(F("Initializing SD card (CS=")); Serial.print(chipSelect); Serial.print(F(")..."));
  
  pinMode(chipSelect, OUTPUT);
  digitalWrite(chipSelect, HIGH);
  delay(100); // Longer delay for stable initialization
  
  // Try to initialize SD card multiple times
  for (int attempt = 1; attempt <= 3; attempt++) {
    if (SD.begin(chipSelect)) {
      Serial.println(F(" Success!"));
      
      // Test write capability to ensure SD card is working
      File testFile = SD.open("/test.txt", FILE_WRITE);
      if (testFile) {
        testFile.println("SD card test");
        testFile.flush();
        testFile.close();
        
        // Try to read it back to verify
        testFile = SD.open("/test.txt", FILE_READ);
        if (testFile) {
          String testContent = testFile.readString();
          testFile.close();
          SD.remove("/test.txt"); // Clean up test file
          
          if (testContent.indexOf("SD card test") >= 0) {
            Serial.println(F("SD Card write/read test: PASSED"));
            return true;
          }
        }
      }
      Serial.println(F("ERROR: SD Card write/read test failed"));
      return false;
    }
    
    Serial.print(F(" Failed attempt ")); Serial.print(attempt);
    if (attempt < 3) {
      Serial.println(F(", retrying..."));
      delay(500);
    } else {
      Serial.println(F(", giving up."));
    }
  }
  
  return false;
}

void createCSVHeader() {
  if (!sdCardReady) return;
  
  // Find an available filename by checking incremental numbers
  strcpy(LOG_FILENAME, "solar.csv"); // Start with base filename
  int fileNumber = 0;
  
  while (SD.exists(LOG_FILENAME)) {
    fileNumber++;
    snprintf(LOG_FILENAME, sizeof(LOG_FILENAME), "solar%d.csv", fileNumber);
    
    // Safety check to prevent infinite loop (max 999 files)
    if (fileNumber > 999) {
      Serial.println(F("ERROR: Too many log files! Cannot create new file."));
      sdCardReady = false;
      return;
    }
  }
  
  // Report which filename will be used
  if (fileNumber == 0) {
    Serial.println(F("Creating new log file: solar.csv"));
  } else {
    Serial.print(F("Files solar.csv"));
    if (fileNumber > 1) {
      Serial.print(F(" through solar")); Serial.print(fileNumber-1); Serial.print(F(".csv"));
    }
    Serial.print(F(" already exist. Creating: ")); Serial.println(LOG_FILENAME);
  }
  
  // Create the new file with CSV header
  Serial.println(F("Creating new log file with CSV header..."));
  File logFile = SD.open(LOG_FILENAME, FILE_WRITE);
  if (logFile) {
    logFile.println("Date,Time,Lux,Latitude,Longitude,GPS_Fix,GPS_Sats,Solar_V,Solar_mA,Solar_mW,Solar_Temp,Battery_V,Battery_mA,Battery_mW,Battery_Temp,Load_V,Load_mA,Load_mW,Load_Temp");
    logFile.flush(); // Ensure header is written immediately
    logFile.close();
    Serial.println(F("CSV header created successfully."));
  } else {
    Serial.println(F("ERROR: Failed to create CSV header!"));
    sdCardReady = false;
  }
}

void logDataToSD(const SensorData& data) {
  if (!sdCardReady) return;
  
  // Open file for append
  File logFile = SD.open(LOG_FILENAME, FILE_WRITE);
  if (!logFile) {
    Serial.print(F("ERROR: Failed to open log file: ")); Serial.println(LOG_FILENAME);
    // Try to reinitialize SD card
    if (initSDCard()) {
      sdCardReady = true;
      logFile = SD.open(LOG_FILENAME, FILE_WRITE);
    } else {
      sdCardReady = false;
      return;
    }
  }
  
  if (logFile) {
    // Write data to file
    logFile.print(data.date_str); logFile.print(",");
    logFile.print(data.time_str); logFile.print(",");
    logFile.print(data.lux, 2); logFile.print(",");
    logFile.print(data.latitude, 6); logFile.print(",");
    logFile.print(data.longitude, 6); logFile.print(",");
    logFile.print(data.gps_fix ? "1" : "0"); logFile.print(",");
    logFile.print(data.gps_satellites); logFile.print(",");
    logFile.print(data.solar_voltage, 4); logFile.print(",");
    logFile.print(data.solar_current, 3); logFile.print(",");
    logFile.print(data.solar_power, 3); logFile.print(",");
    logFile.print(data.solar_temperature, 2); logFile.print(",");
    logFile.print(data.battery_voltage, 4); logFile.print(",");
    logFile.print(data.battery_current, 3); logFile.print(",");
    logFile.print(data.battery_power, 3); logFile.print(",");
    logFile.print(data.battery_temperature, 2); logFile.print(",");
    logFile.print(data.load_voltage, 4); logFile.print(",");
    logFile.print(data.load_current, 3); logFile.print(",");
    logFile.print(data.load_power, 3); logFile.print(",");
    logFile.println(data.load_temperature, 2);
    
    // CRITICAL: Flush data to ensure it's written to SD card immediately
    logFile.flush();
    
    // Verify the write was successful
    if (logFile.getWriteError()) {
      Serial.print(F("ERROR: SD card write error on ")); Serial.println(LOG_FILENAME);
    } else {
      // Only print success message if serial is connected (to avoid spam)
      if (Serial) {
        static unsigned long lastPrintTime = 0;
        if (millis() - lastPrintTime > 10000) { // Print every 10 seconds
          Serial.print(F("SD: Data logged to ")); Serial.println(LOG_FILENAME);
          lastPrintTime = millis();
        }
      }
    }
    
    logFile.close();
  } else {
    Serial.print(F("ERROR: Could not open log file after retry: ")); Serial.println(LOG_FILENAME);
    sdCardReady = false;
  }
}

SensorData readAllSensors() {
  SensorData data = {0};
  updateRTCTimestamp(data); // Get timestamp from RTC
  
  // Read light sensor
  if (lightMeter.hasValue()) {
    data.lux = lightMeter.getLux();
  }

  // Read GNSS data
  readGNSSData(data);

  // Variables for raw register values (for debugging if needed)
  uint32_t rawVBus, shiftedVBus;
  int32_t rawVShunt, shiftedVShunt;
  int32_t rawCurrent, shiftedCurrent;
  uint32_t rawPower;
  uint16_t rawTemp;

  // Read Solar Panel data
  if (solar_current_lsb > 0.0f) {
    data.solar_voltage = readBusVoltage(INA_SOLAR_ADDR, rawVBus, shiftedVBus);
    readShuntVoltage(INA_SOLAR_ADDR, rawVShunt, shiftedVShunt); // Read but don't store
    data.solar_current = readCurrent(INA_SOLAR_ADDR, solar_current_lsb, rawCurrent, shiftedCurrent);
    data.solar_power = readPower(INA_SOLAR_ADDR, solar_current_lsb, rawPower);
    data.solar_temperature = readTemperature(INA_SOLAR_ADDR, rawTemp);
  }
  
  // Read Battery data
  if (battery_current_lsb > 0.0f) {
    data.battery_voltage = readBusVoltage(INA_BATTERY_ADDR, rawVBus, shiftedVBus);
    float shuntV = readShuntVoltage(INA_BATTERY_ADDR, rawVShunt, shiftedVShunt);
    
    // Calculate current directly from shunt voltage and effective resistance
    // This approach is more intuitive and eliminates the need for correction factors
    // Current (mA) = Shunt Voltage (mV) / Effective Resistance (ohms)
    data.battery_current = shuntV / EFFECTIVE_SHUNT_OHMS_BATTERY;
    
    // Calculate power preserving sign convention: P = V × I
    // Negative current (charging) will result in negative power
    // Positive current (discharging) will result in positive power
    data.battery_power = data.battery_voltage * data.battery_current;
    
    data.battery_temperature = readTemperature(INA_BATTERY_ADDR, rawTemp);
    
    // Read chip values for comparison (debugging)
    float current_from_chip = readCurrent(INA_BATTERY_ADDR, battery_current_lsb, rawCurrent, shiftedCurrent);
    float power_from_chip = readPower(INA_BATTERY_ADDR, battery_current_lsb, rawPower);
    
    // Debug output removed for cleaner display
  }
  
  // Read Load data
  if (load_current_lsb > 0.0f) {
    data.load_voltage = readBusVoltage(INA_LOAD_ADDR, rawVBus, shiftedVBus);
    readShuntVoltage(INA_LOAD_ADDR, rawVShunt, shiftedVShunt); // Read but don't store
    data.load_current = readCurrent(INA_LOAD_ADDR, load_current_lsb, rawCurrent, shiftedCurrent);
    data.load_power = readPower(INA_LOAD_ADDR, load_current_lsb, rawPower);
    data.load_temperature = readTemperature(INA_LOAD_ADDR, rawTemp);
  }
  
  return data;
}

float initINA228(uint8_t address, const char* sensorName, float shuntOhms, float maxCurrent) {
  Serial.print(F("\nAttempting to initialize INA228: ")); Serial.println(sensorName);
  Wire.beginTransmission(address);
  if (Wire.endTransmission() != 0) {
    Serial.print(F("  ERROR: INA228 not found at address 0x")); Serial.println(address, HEX);
    return 0.0f; 
  }
  Serial.print(F("  Device found at 0x")); Serial.println(address, HEX);
  
  // Reset the device
  Wire.beginTransmission(address);
  Wire.write(INA228_REG_CONFIG);
  Wire.write((uint8_t)0x80); 
  Wire.write((uint8_t)0x00); 
  if (Wire.endTransmission() != 0) {
    Serial.print(F("  ERROR: Failed to send reset to INA228 0x")); Serial.println(address, HEX);
    return 0.0f;
  }
  Serial.println(F("  Device reset command sent."));
  delay(10); 
  
  // Configure ADC for continuous bus, shunt, and temperature monitoring
  // ADC_CONFIG register: MODE = 0xF (continuous temp + bus + shunt)
  // VBUSCT = 5 (1052 us), VSHCT = 5 (1052 us), VTCT = 5 (1052 us), AVG = 0 (1 sample)
  uint16_t adcConfig = 0xF000 | (5 << 9) | (5 << 6) | (5 << 3) | 0;
  Wire.beginTransmission(address);
  Wire.write(INA228_REG_ADCCFG);
  Wire.write((uint8_t)((adcConfig >> 8) & 0xFF)); 
  Wire.write((uint8_t)(adcConfig & 0xFF));       
  if (Wire.endTransmission() != 0) {
    Serial.print(F("  ERROR: Failed to write ADC_CONFIG to INA228 0x")); Serial.println(address, HEX);
    return 0.0f;
  }
  Serial.println(F("  ADC configured for continuous monitoring with temperature."));
  
  float device_current_lsb = maxCurrent / 524288.0f; 
  uint16_t calibration = (uint16_t)(13107.2f * 1000000.0f * device_current_lsb * shuntOhms);
  Serial.print(F("  Calculated device_current_lsb (A/bit): ")); Serial.println(device_current_lsb, 10);
  Serial.print(F("  Calculated SHUNT_CAL value: 0x")); Serial.print(calibration, HEX); Serial.print(F(" (")); Serial.print(calibration); Serial.println(F(")"));
  
  Wire.beginTransmission(address);
  Wire.write(INA228_REG_SHUNTCAL);
  Wire.write((uint8_t)((calibration >> 8) & 0xFF)); 
  Wire.write((uint8_t)(calibration & 0xFF));       
  if (Wire.endTransmission() != 0) {
    Serial.print(F("  ERROR: Failed to write SHUNT_CAL to INA228 0x")); Serial.println(address, HEX);
    return 0.0f;
  }
  Serial.println(F("  SHUNT_CAL value written."));
  Serial.println(F("  Temperature monitoring enabled."));
  
  return device_current_lsb;
}

void inspectINA228Registers(uint8_t address, const char* sensorName) {
  Serial.print(F("Inspecting registers for INA228: ")); Serial.println(sensorName);
  
  uint16_t configReg = readRegister16(address, INA228_REG_CONFIG);
  Serial.print(F("  CONFIG (0x00)      : 0x")); Serial.println(configReg, HEX);
  Serial.print(F("    ADCRANGE (Bit 4) : ")); Serial.println((configReg >> 4) & 0x1);

  uint16_t adcConfigReg = readRegister16(address, INA228_REG_ADCCFG);
  Serial.print(F("  ADC_CONFIG (0x01)  : 0x")); Serial.println(adcConfigReg, HEX);
  Serial.print(F("    MODE (Bits 15-12): 0x")); Serial.println((adcConfigReg >> 12) & 0xF, HEX);
  Serial.print(F("    VBUSCT (Bits 11-9): 0x")); Serial.println((adcConfigReg >> 9) & 0x7, HEX);
  Serial.print(F("    VSHCT (Bits 8-6) : 0x")); Serial.println((adcConfigReg >> 6) & 0x7, HEX);
  Serial.print(F("    VTCT (Bits 5-3)  : 0x")); Serial.println((adcConfigReg >> 3) & 0x7, HEX);
  Serial.print(F("    AVG (Bits 2-0)   : 0x")); Serial.println(adcConfigReg & 0x7, HEX);


  uint16_t shuntCalReg = readRegister16(address, INA228_REG_SHUNTCAL);
  Serial.print(F("  SHUNT_CAL (0x02)   : 0x")); Serial.print(shuntCalReg, HEX);
  Serial.print(F(" (")); Serial.print(shuntCalReg); Serial.println(F(")"));

  uint16_t mfgID = readRegister16(address, INA228_REG_MFG_UID);
  Serial.print(F("  MANUFACTURER_ID (0x3E): 0x")); Serial.println(mfgID, HEX);
  
  uint16_t devID = readRegister16(address, INA228_REG_DEVICE_ID);
  Serial.print(F("  DEVICE_ID (0x3F)   : 0x")); Serial.println(devID, HEX);
  Serial.print(F("    DIEID (Bits 15-4): 0x")); Serial.println((devID >> 4) & 0xFFF, HEX);
  Serial.print(F("    REVID (Bits 3-0) : 0x")); Serial.println(devID & 0xF, HEX);
}

uint16_t readRegister16(uint8_t address, uint8_t reg) {
  uint16_t value = 0;
  
  Wire.beginTransmission(address);
  Wire.write(reg);
  if (Wire.endTransmission(false) != 0) { 
    Serial.print(F("readRegister16: Failed to send reg address 0x")); Serial.print(reg, HEX);
    Serial.print(F(" to device 0x")); Serial.println(address, HEX);
    return 0; 
  }
  
  uint8_t bytesRead = Wire.requestFrom(address, (uint8_t)2);
  
  if (bytesRead == 2) {
    // Read MSB first, then LSB (MSBFIRST like Adafruit library)
    value = (Wire.read() << 8) | Wire.read();
  } else {
    Serial.print(F("readRegister16: Failed to read 2 bytes from reg 0x")); Serial.print(reg, HEX);
    Serial.print(F(" on device 0x")); Serial.println(address, HEX);
    Serial.print(F("  Bytes actually read: ")); Serial.println(bytesRead);
    return 0; 
  }
  return value;
}

float readBusVoltage(uint8_t address, uint32_t& rawRegValue, uint32_t& shiftedRegValue) {
  rawRegValue = readRegister(address, INA228_REG_VBUS, 3); 
  shiftedRegValue = rawRegValue >> 4; 
  return (float)shiftedRegValue * 195.3125f / 1000000.0f; 
}

float readShuntVoltage(uint8_t address, int32_t& rawRegValue, int32_t& shiftedRegValue) {
  uint32_t temp_raw = readRegister(address, INA228_REG_VSHUNT, 3);
  rawRegValue = (int32_t)temp_raw; // Store the 24-bit raw value before sign extension for debug print

  // Perform sign extension on a temporary variable if needed, or ensure rawRegValue is correctly representing the 24-bit signedness
  int32_t signed_raw_value = (int32_t)temp_raw; // Cast to int32_t
  if (signed_raw_value & 0x800000) { // Check 24th bit (bit 23 of 0-23 range)
    signed_raw_value |= 0xFF000000;   // Sign extend to 32 bits
  }
  // rawRegValue for printing should ideally be the value before sign extension if you want to see the "as read" 24 bits.
  // The value used for calculation IS the sign-extended one. Let's keep rawRegValue as the direct 24-bit read.

  shiftedRegValue = signed_raw_value >> 4; 
  return (float)shiftedRegValue * 0.0003125f;
}

float readCurrent(uint8_t address, float current_lsb_value, int32_t& rawRegValue, int32_t& shiftedRegValue) {
  if (current_lsb_value == 0.0f) {
    rawRegValue = 0; shiftedRegValue = 0;
    return 0.0f; 
  }
  uint32_t temp_raw = readRegister(address, INA228_REG_CURRENT, 3);
  rawRegValue = (int32_t)temp_raw; // Store the 24-bit raw value

  int32_t signed_raw_value = (int32_t)temp_raw;
  if (signed_raw_value & 0x800000) { 
    signed_raw_value |= 0xFF000000;
  }
  shiftedRegValue = signed_raw_value >> 4;
  return (float)shiftedRegValue * current_lsb_value * 1000.0f; 
}

float readPower(uint8_t address, float current_lsb_value, uint32_t& rawRegValue) {
  if (current_lsb_value == 0.0f) {
    rawRegValue = 0;
    return 0.0f; 
  }
  rawRegValue = readRegister(address, INA228_REG_POWER, 3); 
  return (float)rawRegValue * 3.2f * current_lsb_value * 1000.0f;
}

float readTemperature(uint8_t address, uint16_t& rawRegValue) {
  rawRegValue = readRegister16(address, INA228_REG_DIETEMP);
  // INA228 temperature conversion from datasheet:
  // Temperature (°C) = rawValue * 7.8125e-3
  // No offset needed - direct conversion from raw value
  // Raw value of 0x1900 (6400 decimal) = ~50°C
  // Raw value of 0x1000 (4096 decimal) = ~32°C  
  
  // Temperature debug output removed for cleaner display
  
  return (float)rawRegValue * 0.0078125f;
}

uint32_t readRegister(uint8_t address, uint8_t reg, uint8_t numBytes) {
  uint32_t value = 0;
  
  Wire.beginTransmission(address);
  Wire.write(reg);
  if (Wire.endTransmission(false) != 0) { 
    Serial.print(F("readRegister: Failed to send reg address 0x")); Serial.print(reg, HEX);
    Serial.print(F(" to device 0x")); Serial.println(address, HEX);
    return 0; 
  }
  
  uint8_t bytesRead = Wire.requestFrom(address, numBytes);
  
  if (bytesRead == numBytes) {
    for (uint8_t i = 0; i < numBytes; i++) { 
      value = (value << 8) | Wire.read();
    }
  } else {
    Serial.print(F("readRegister: Failed to read ")); Serial.print(numBytes);
    Serial.print(F(" bytes from reg 0x")); Serial.print(reg, HEX);
    Serial.print(F(" on device 0x")); Serial.println(address, HEX);
    Serial.print(F("  Bytes actually read: ")); Serial.println(bytesRead);
    return 0; 
  }
  return value;
}

void listExistingLogFiles() {
  Serial.println(F("--- Existing Solar Log Files ---"));
  
  // Check base file
  if (SD.exists("solar.csv")) {
    File file = SD.open("solar.csv", FILE_READ);
    if (file) {
      Serial.print(F("solar.csv - ")); Serial.print(file.size()); Serial.println(F(" bytes"));
      file.close();
    }
  }
  
  // Check numbered files
  int count = 0;
  for (int i = 1; i <= 999; i++) {
    char filename[20];
    snprintf(filename, sizeof(filename), "solar%d.csv", i);
    
    if (SD.exists(filename)) {
      File file = SD.open(filename, FILE_READ);
      if (file) {
        Serial.print(filename); Serial.print(F(" - ")); Serial.print(file.size()); Serial.println(F(" bytes"));
        file.close();
        count++;
      }
    } else {
      break; // Stop when we find the first non-existent file
    }
  }
  
  if (count == 0 && !SD.exists("solar.csv")) {
    Serial.println(F("No solar log files found."));
  } else {
    Serial.print(F("Total files found: ")); 
    Serial.println(SD.exists("solar.csv") ? count + 1 : count);
  }
  Serial.println(F("--------------------------------"));
}

bool initRTC() {
  if (rtc.begin() == false) {
    Serial.println(F("Something went wrong with RTC, check wiring"));
    return false;
  }

  Serial.println(F("RTC online!"));
  
  // Set default time zone to Central Daylight Time (CDT = UTC-5)
  setTimeZone(true); // true = Daylight Time (CDT)
  
  // Check if this is the first time running or if RTC lost power
  if (rtc.getSeconds() == 0 && rtc.getMinutes() == 0 && rtc.getHours() == 0) {
    Serial.println(F("RTC appears to be reset. Consider setting time."));
  }
  
  return true;
}

void setTimeZone(bool isDST) {
  if (isDST) {
    // Central Daylight Time (CDT) = UTC-5 hours = -20 quarter hours
    rtc.setTimeZoneQuarterHours(-20);
    currentTimeZone = -20;
    Serial.println(F("Time zone set to CDT (UTC-5)"));
  } else {
    // Central Standard Time (CST) = UTC-6 hours = -24 quarter hours  
    rtc.setTimeZoneQuarterHours(-24);
    currentTimeZone = -24;
    Serial.println(F("Time zone set to CST (UTC-6)"));
  }
}

void printRTCStatus() {
  if (rtc.updateTime() == false) {
    Serial.println(F("RTC failed to update"));
    return;
  }

  String currentDate = rtc.stringDateUSA(); // MM/DD/YYYY
  String currentTime = rtc.stringTime();     // HH:MM:SS
  
  Serial.print(F("Current Date: ")); Serial.println(currentDate);
  Serial.print(F("Current Time: ")); Serial.println(currentTime);
  
  if (currentTimeZone == -24) {
    Serial.println(F("Time Zone: CST (UTC-6)"));
  } else if (currentTimeZone == -20) {
    Serial.println(F("Time Zone: CDT (UTC-5)"));
  } else {
    Serial.print(F("Time Zone: UTC")); Serial.println(currentTimeZone / 4.0f, 1);
  }
}

void handleSerialTimeCommands() {
  char command = Serial.read();
  
  // Debug output to see what command was received
  Serial.print(F("DEBUG: Received command: '"));
  Serial.print(command);
  Serial.print(F("' (ASCII: "));
  Serial.print((int)command);
  Serial.println(F(")"));
  
  // Clear any remaining characters including newlines
  delay(10); // Small delay to ensure all characters arrive
  while (Serial.available()) {
    char extra = Serial.read();
    Serial.print(F("DEBUG: Clearing extra char: '"));
    Serial.print(extra);
    Serial.print(F("' (ASCII: "));
    Serial.print((int)extra);
    Serial.println(F(")"));
  }
  
  switch (command) {
    case 's':
    case 'S':
      {
        // Set time to compiler time
        Serial.println(F("Setting RTC to compiler time..."));
        if (rtc.setToCompilerTime() == false) {
          Serial.println(F("Failed to set compiler time!"));
        } else {
          Serial.println(F("RTC set to compiler time successfully!"));
          printRTCStatus();
        }
      }
      break;
      
    case 't':
    case 'T':
      {
        // Set custom time - using braces to properly scope variables
        Serial.println(F("DEBUG: Entering custom time setting mode"));
        Serial.println(F("Custom time setting:"));
        Serial.print(F("Enter year (YYYY): "));
        Serial.flush(); // Ensure prompt is sent
        
        // Wait for input with timeout
        unsigned long startTime = millis();
        while (!Serial.available() && (millis() - startTime < 30000)) {
          delay(100);
        }
        if (!Serial.available()) {
          Serial.println(F("Timeout waiting for year input"));
          return;
        }
        int year = Serial.parseInt();
        Serial.println(year); // Echo back the input
        
        Serial.print(F("Enter month (1-12): "));
        Serial.flush();
        startTime = millis();
        while (!Serial.available() && (millis() - startTime < 30000)) {
          delay(100);
        }
        if (!Serial.available()) {
          Serial.println(F("Timeout waiting for month input"));
          return;
        }
        int month = Serial.parseInt();
        Serial.println(month);
        
        Serial.print(F("Enter day (1-31): "));
        Serial.flush();
        startTime = millis();
        while (!Serial.available() && (millis() - startTime < 30000)) {
          delay(100);
        }
        if (!Serial.available()) {
          Serial.println(F("Timeout waiting for day input"));
          return;
        }
        int day = Serial.parseInt();
        Serial.println(day);
        
        Serial.print(F("Enter hour (0-23): "));
        Serial.flush();
        startTime = millis();
        while (!Serial.available() && (millis() - startTime < 30000)) {
          delay(100);
        }
        if (!Serial.available()) {
          Serial.println(F("Timeout waiting for hour input"));
          return;
        }
        int hour = Serial.parseInt();
        Serial.println(hour);
        
        Serial.print(F("Enter minute (0-59): "));
        Serial.flush();
        startTime = millis();
        while (!Serial.available() && (millis() - startTime < 30000)) {
          delay(100);
        }
        if (!Serial.available()) {
          Serial.println(F("Timeout waiting for minute input"));
          return;
        }
        int minute = Serial.parseInt();
        Serial.println(minute);
        
        Serial.print(F("Enter second (0-59): "));
        Serial.flush();
        startTime = millis();
        while (!Serial.available() && (millis() - startTime < 30000)) {
          delay(100);
        }
        if (!Serial.available()) {
          Serial.println(F("Timeout waiting for second input"));
          return;
        }
        int second = Serial.parseInt();
        Serial.println(second);
        
        // Clear input buffer
        while (Serial.available()) Serial.read();
        
        Serial.print(F("Setting time to: "));
        Serial.print(month); Serial.print(F("/"));
        Serial.print(day); Serial.print(F("/"));
        Serial.print(year); Serial.print(F(" "));
        Serial.print(hour); Serial.print(F(":"));
        Serial.print(minute); Serial.print(F(":"));
        Serial.println(second);
        
        if (rtc.setTime(second, minute, hour, 1, day, month, year) == false) {
          Serial.println(F("Failed to set custom time!"));
        } else {
          Serial.println(F("Custom time set successfully!"));
          printRTCStatus();
        }
      }
      break;
      
    case 'z':
    case 'Z':
      {
        // Toggle time zone
        if (currentTimeZone == -24) {
          setTimeZone(true); // Switch to CDT
        } else {
          setTimeZone(false); // Switch to CST
        }
        printRTCStatus();
      }
      break;
      
    case 'c':
    case 'C':
      {
        Serial.println(F("Continuing with current time..."));
      }
      break;
      
    default:
      {
        Serial.print(F("Invalid command '"));
        Serial.print(command);
        Serial.println(F("'. Continuing with current time..."));
      }
      break;
  }
}

void updateRTCTimestamp(SensorData& data) {
  data.timestamp_ms = millis(); // Keep millis for timing intervals
  
  if (rtc.updateTime() == false) {
    // If RTC update fails, use a fallback timestamp
    strcpy(data.date_str, "RTC_ERROR");
    strcpy(data.time_str, "RTC_ERROR");
    return;
  }
  
  // Create ISO 8601 formatted timestamp: YYYY-MM-DDTHH:MM:SS
  // Note: RV8803 library getYear() already returns 4-digit year (e.g., 2025)
  snprintf(data.date_str, sizeof(data.date_str), 
           "%04d-%02d-%02d",
           rtc.getYear(),      // Already 4-digit year, no need to add 2000
           rtc.getMonth(),
           rtc.getDate());
  snprintf(data.time_str, sizeof(data.time_str), 
           "%02d:%02d:%02d",
           rtc.getHours(),
           rtc.getMinutes(),
           rtc.getSeconds());
}

// Note: handleTimeAdjustmentCommands() function removed - functionality integrated into main menu

// Simple menu functions for RTC adjustment
void showRealTimeDisplay() {
  Serial.println(F("=== Real-Time Display (Press 'q' to exit) ==="));
  
  // Clear serial buffer before starting
  while (Serial.available()) {
    Serial.read();
  }
  
  unsigned long lastUpdate = 0;
  
  while (true) {
    // Check for exit command using direct character reading
    char command = readSerialCommand();
    if (command == 'q' || command == 'Q') {
      Serial.println(F("\nExiting real-time display..."));
      break;
    }
    
    // Update display every 500ms
    if (millis() - lastUpdate > 500) {
      if (rtc.updateTime()) {
        Serial.print(F("RTC Time: "));
        Serial.print(rtc.stringTime8601());
        Serial.print(F(" | "));
        Serial.print(rtc.stringTime());
        if (currentTimeZone == -24) {
          Serial.print(F(" CST"));
        } else if (currentTimeZone == -20) {
          Serial.print(F(" CDT"));
        }
        Serial.println(); // Use newline instead of carriage return
        Serial.flush(); // Ensure output is sent
      }
      lastUpdate = millis();
    }
    
    delay(10); // Small delay for responsiveness
  }
}

void adjustTimeSeconds(int seconds) {
  Serial.print(F("Adjusting time by "));
  Serial.print(seconds);
  Serial.println(F(" seconds..."));
  
  if (rtc.updateTime() == false) {
    Serial.println(F("ERROR: Failed to read current time!"));
    return;
  }
  
  // Get current time components
  uint8_t currentSeconds = rtc.getSeconds();
  uint8_t currentMinutes = rtc.getMinutes();
  uint8_t currentHours = rtc.getHours();
  uint8_t currentDay = rtc.getDate();
  uint8_t currentMonth = rtc.getMonth();
  uint16_t currentYear = rtc.getYear();
  uint8_t currentWeekday = rtc.getWeekday();
  
  Serial.print(F("Current time: "));
  Serial.print(currentHours); Serial.print(F(":"));
  Serial.print(currentMinutes); Serial.print(F(":"));
  Serial.println(currentSeconds);
  
  // Calculate new seconds with proper overflow handling
  int newSeconds = currentSeconds + seconds;
  int carryMinutes = 0;
  
  if (newSeconds >= 60) {
    carryMinutes = newSeconds / 60;
    newSeconds = newSeconds % 60;
  } else if (newSeconds < 0) {
    carryMinutes = (newSeconds - 59) / 60; // This will be negative
    newSeconds = (newSeconds % 60 + 60) % 60;
  }
  
  int newMinutes = currentMinutes + carryMinutes;
  int carryHours = 0;
  
  if (newMinutes >= 60) {
    carryHours = newMinutes / 60;
    newMinutes = newMinutes % 60;
  } else if (newMinutes < 0) {
    carryHours = (newMinutes - 59) / 60;
    newMinutes = (newMinutes % 60 + 60) % 60;
  }
  
  int newHours = currentHours + carryHours;
  if (newHours >= 24) {
    newHours = newHours % 24;
  } else if (newHours < 0) {
    newHours = (newHours % 24 + 24) % 24;
  }
  
  Serial.print(F("New time will be: "));
  Serial.print(newHours); Serial.print(F(":"));
  Serial.print(newMinutes); Serial.print(F(":"));
  Serial.println(newSeconds);
  
  // Set the new time
  bool success = rtc.setTime((uint8_t)newSeconds, (uint8_t)newMinutes, (uint8_t)newHours, 
                             currentWeekday, currentDay, currentMonth, currentYear);
  
  if (success) {
    Serial.println(F("Time adjustment successful!"));
    // Verify the change by reading it back
    delay(100);
    if (rtc.updateTime()) {
      Serial.print(F("Verified new time: "));
      Serial.print(rtc.getHours()); Serial.print(F(":"));
      Serial.print(rtc.getMinutes()); Serial.print(F(":"));
      Serial.println(rtc.getSeconds());
    }
  } else {
    Serial.println(F("ERROR: Failed to set new time!"));
  }
}

void toggleTimeZone() {
  if (currentTimeZone == -24) {  // CST to CDT
    currentTimeZone = -20;
    rtc.setTimeZoneQuarterHours(currentTimeZone);
    Serial.println(F("Time zone changed to CDT (UTC-5)"));
  } else {  // CDT to CST
    currentTimeZone = -24;
    rtc.setTimeZoneQuarterHours(currentTimeZone);
    Serial.println(F("Time zone changed to CST (UTC-6)"));
  }
}

// Enhanced real-time display with multi-second adjustments
void showEnhancedRealTimeDisplay() {
  Serial.println(F("=== Real-Time Display (Send commands or 'c' to continue) ==="));
  Serial.println(F("Commands: +N (e.g., +10), -N (e.g., -5), z (timezone), d (debug), g (gnss sync), c (continue)"));
  Serial.println(F("Auto-timeout in 30 seconds if no commands received..."));
  
  // Clear serial buffer before starting
  while (Serial.available()) {
    Serial.read();
  }
  
  unsigned long lastUpdate = 0;
  unsigned long sessionStartTime = millis(); // Track session start time
  unsigned long lastUserActivity = millis(); // Track last user input
  static String commandBuffer = "";
  static unsigned long lastCommandTime = 0;
  
  const unsigned long AUTO_TIMEOUT_MS = 30000; // 30 second timeout
  const unsigned long USER_TIMEOUT_MS = 60000; // 60 seconds after last user activity
  
  // Test if serial monitor is actually connected by attempting to read
  // If Serial.available() never changes after a reasonable time, assume no monitor
  bool serialMonitorDetected = false;
  unsigned long detectionStart = millis();
  
  while ((millis() - sessionStartTime < AUTO_TIMEOUT_MS) && Serial) {
    // Update display every 500ms
    if (millis() - lastUpdate > 500) {
      if (rtc.updateTime()) {
        Serial.print(F("RTC Time: "));
        Serial.print(rtc.stringTime8601());
        Serial.print(F(" | "));
        Serial.print(rtc.stringTime());
        if (currentTimeZone == -24) {
          Serial.print(F(" CST"));
        } else if (currentTimeZone == -20) {
          Serial.print(F(" CDT"));
        }
        Serial.println(); // Use newline instead of carriage return
        Serial.flush(); // Ensure output is sent
      }
      lastUpdate = millis();
    }
    
    // Auto-execute command buffer after 1 second of no input (user finished typing)
    if (commandBuffer.length() > 0 && (millis() - lastCommandTime > 1000)) {
      executeTimeCommand(commandBuffer);
      commandBuffer = ""; // Clear buffer
    }
    
    // Check for commands using the working character-by-character method
    char command = readSerialCommand();
    if (command != 0) {
      serialMonitorDetected = true; // We received actual input
      lastCommandTime = millis(); // Update last command time
      lastUserActivity = millis(); // Update user activity time
      
      if (serialDebugMode) {
        Serial.print(F("DEBUG: Received char: '"));
        Serial.print(command);
        Serial.println(F("'"));
      }
      
      // Handle immediate single-character commands
      if (command == 'c' || command == 'C') {
        Serial.println(F("\nContinuing to main program..."));
        break;
      }
      else if (command == 'z' || command == 'Z') {
        toggleTimeZone();
        commandBuffer = ""; // Clear buffer
      }
      else if (command == 'd' || command == 'D') {
        serialDebugMode = !serialDebugMode;
        Serial.print(F("Serial debug mode: "));
        Serial.println(serialDebugMode ? F("ENABLED") : F("DISABLED"));
        commandBuffer = ""; // Clear buffer
      }
      else if (command == 'g' || command == 'G') {
        Serial.print(F("Manual GNSS time sync..."));
        
        // Enhanced GPS diagnostic information
        SensorData tempData;
        readGNSSData(tempData);
        
        Serial.println(); // New line for better formatting
        Serial.print(F("GPS Status Check:"));
        Serial.print(F(" Satellites: ")); Serial.print(tempData.gps_satellites);
        Serial.print(F(", Fix: ")); Serial.print(tempData.gps_fix ? "YES" : "NO");
        Serial.print(F(", isGNSSFixed: ")); Serial.print(isGNSSFixed ? "YES" : "NO");
        
        // Additional validation info
        int numSats = myGNSS.getSIV();
        float hdop = myGNSS.getHorizontalDOP() / 100.0;
        bool gnssFixOk = myGNSS.getGnssFixOk();
        bool validationOk = validateGnssData();
        
        Serial.println();
        Serial.print(F("Validation Details:"));
        Serial.print(F(" GNSS Fix OK: ")); Serial.print(gnssFixOk ? "YES" : "NO");
        Serial.print(F(", Sats (min 4): ")); Serial.print(numSats);
        Serial.print(F(", HDOP (max 5.0): ")); Serial.print(hdop, 2);
        Serial.print(F(", Validation: ")); Serial.println(validationOk ? "PASS" : "FAIL");
        
        if (syncRTCWithGNSSLocal()) {
          Serial.println(F("SUCCESS: RTC synced with GNSS time!"));
          lastGnssTimeSync = millis();
        } else {
          Serial.println(F("FAILED: GPS sync not possible"));
          if (!gnssFixOk) {
            Serial.println(F("Reason: No GPS fix available"));
          } else if (numSats < 4) {
            Serial.println(F("Reason: Insufficient satellites (need ≥4)"));
          } else if (hdop > 5.0) {
            Serial.print(F("Reason: Poor GPS precision (HDOP=")); 
            Serial.print(hdop, 2); Serial.println(F(" > 5.0)"));
          } else {
            Serial.println(F("Reason: Unknown validation failure"));
          }
          Serial.println(F("GPS modules may take 30-90 seconds for initial fix"));
        }
        commandBuffer = ""; // Clear buffer
      }
      else if (command == '\r' || command == '\n') {
        // Execute buffered command immediately on Enter
        if (commandBuffer.length() > 0) {
          executeTimeCommand(commandBuffer);
          commandBuffer = ""; // Clear buffer
        }
      }
      else if (command == '+' || command == '-' || (command >= '0' && command <= '9')) {
        // Building a multi-character command
        if (command == '+' || command == '-') {
          commandBuffer = String(command); // Start new command
        } else {
          commandBuffer += command; // Add digit
        }
        
        // Show progress
        Serial.print(F("Building command: "));
        Serial.print(commandBuffer);
        Serial.println(F(" (will execute in 1 sec or press Enter)"));
      }
      else {
        // Unknown single character - try to execute immediately
        String singleCmd = String(command);
        executeTimeCommand(singleCmd);
        commandBuffer = ""; // Clear buffer
      }
    }
    
    // Check for early auto-timeout if no serial monitor is detected
    if (!serialMonitorDetected && (millis() - detectionStart > 5000)) {
      Serial.println(F("\nNo serial monitor activity detected - auto-continuing to main program..."));
      break;
    }
    
    // Check for user activity timeout (if user was active but then idle)
    if (serialMonitorDetected && (millis() - lastUserActivity > USER_TIMEOUT_MS)) {
      Serial.println(F("\nUser activity timeout - continuing to main program..."));
      break;
    }
    
    delay(10); // Small delay for responsiveness
  }
  
  // If we exit due to timeout, inform the user
  if (millis() - sessionStartTime >= AUTO_TIMEOUT_MS) {
    Serial.println(F("\nAuto-timeout reached - continuing to main program..."));
  }
  
  Serial.println(F("Real-time display session ended."));
}

// Execute time adjustment commands
void executeTimeCommand(String command) {
  command.trim(); // Remove whitespace
  
  Serial.print(F("Executing command: '"));
  Serial.print(command);
  Serial.println(F("'"));
  
  if (command == "+" || command == "+1") {
    adjustTimeSeconds(1);
  }
  else if (command == "-" || command == "-1") {
    adjustTimeSeconds(-1);
  }
  else if (command.startsWith("+")) {
    String numStr = command.substring(1);
    int seconds = numStr.toInt();
    if (seconds > 0 && seconds <= 3600) { // Limit to 1 hour max
      adjustTimeSeconds(seconds);
    } else {
      Serial.println(F("ERROR: Invalid seconds value (must be 1-3600)"));
    }
  }
  else if (command.startsWith("-")) {
    String numStr = command.substring(1);
    int seconds = numStr.toInt();
    if (seconds > 0 && seconds <= 3600) { // Limit to 1 hour max
      adjustTimeSeconds(-seconds);
    } else {
      Serial.println(F("ERROR: Invalid seconds value (must be 1-3600)"));
    }
  }
  else if (command.length() == 0) {
    // Empty command - ignore
    return;
  }
  else {
    Serial.print(F("ERROR: Unknown command '"));
    Serial.print(command);
    Serial.println(F("' (Try: +10, -5, z, d, c)"));
  }
}

// Read complete string commands from serial (handles multi-character input)
String readSerialCommand_String() {
  static String inputBuffer = "";
  static unsigned long lastCharTime = 0;
  
  // Clear old buffer if no recent activity (timeout after 1 second)
  if (millis() - lastCharTime > 1000 && inputBuffer.length() > 0) {
    inputBuffer = "";
  }
  
  // Read available characters
  while (Serial.available()) {
    char c = Serial.read();
    lastCharTime = millis();
    
    if (c == '\n' || c == '\r') {
      // End of command - return the buffer and clear it
      if (inputBuffer.length() > 0) {
        String result = inputBuffer;
        inputBuffer = "";
        return result;
      }
    } else if (c >= 32 && c <= 126) {
      // Printable character - add to buffer
      inputBuffer += c;
      
      // Limit buffer size for safety
      if (inputBuffer.length() > 20) {
        inputBuffer = inputBuffer.substring(0, 20);
      }
    }
  }
  
  return ""; // No complete command yet
}

// GNSS Functions Implementation
bool initGNSS() {
  Serial.println(F("Initializing GNSS module..."));
  if (!myGNSS.begin()) {
    Serial.println(F("GNSS not detected. Check wiring!"));
    return false;
  }
  Serial.println(F("GNSS initialized successfully"));
  
  // Configure GNSS
  myGNSS.setI2COutput(COM_TYPE_UBX);
  
  // Enable additional GNSS data for validation
  myGNSS.setAutoNAVPVAT(true);      // Enable automatic NAVPVT messages
  myGNSS.setAutoPVT(true);         // Enable navigation position velocity time solution
  myGNSS.setAutoHPPOSLLH(true);    // Enable high precision geodetic position
  
  return true;
}

void readGNSSData(SensorData& data) {
  // Initialize GPS data to defaults
  data.latitude = 0.0;
  data.longitude = 0.0;
  data.gps_fix = false;
  data.gps_satellites = 0;
  
  // Get fresh GNSS data
  myGNSS.checkUblox();
  
  // Check if we have a valid GPS fix
  if (myGNSS.getGnssFixOk() && validateGnssData()) {
    isGNSSFixed = true;
    data.gps_fix = true;
    
    // Convert from millionths of a degree to degrees
    data.latitude = myGNSS.getLatitude() / 10000000.0;
    data.longitude = myGNSS.getLongitude() / 10000000.0;
    data.gps_satellites = myGNSS.getSIV();
  } else {
    isGNSSFixed = false;
    data.gps_fix = false;
    data.gps_satellites = myGNSS.getSIV(); // Still show satellite count even without fix
  }
}

bool validateGnssData() {
  // Minimum satellite count requirement
  const int MIN_GNSS_SATS = 4;
  const float GNSS_HDOP_THRESHOLD = 5.0;
  
  // Check for minimum satellite count
  int numSatellites = myGNSS.getSIV();
  if (numSatellites < MIN_GNSS_SATS) {
    return false;
  }
  
  // Check horizontal dilution of precision (HDOP)
  // Lower values indicate better precision
  float hdop = myGNSS.getHorizontalDOP() / 100.0; // HDOP is reported in cm
  if (hdop > GNSS_HDOP_THRESHOLD) {
    return false;
  }
  
  return true;
}

// GNSS Time Synchronization Functions
bool syncRTCWithGNSS() {
  // Sync RTC with GNSS UTC time (no timezone adjustment)
  if (!isGNSSFixed || !validateGnssData()) {
    return false;
  }
  
  // Get time from GNSS
  uint8_t hour = myGNSS.getHour();
  uint8_t minute = myGNSS.getMinute();
  uint8_t second = myGNSS.getSecond();
  uint8_t day = myGNSS.getDay();
  uint8_t month = myGNSS.getMonth();
  uint16_t year = myGNSS.getYear();
  
  // Set RTC time
  bool result = rtc.setTime(second, minute, hour, 1, day, month, year); // 1 = Sunday (placeholder)
  
  if (result) {
    Serial.print(F("RTC synced to GNSS UTC: "));
    Serial.print(year); Serial.print(F("/"));
    Serial.print(month); Serial.print(F("/"));
    Serial.print(day); Serial.print(F(" "));
    Serial.print(hour); Serial.print(F(":"));
    Serial.print(minute); Serial.print(F(":"));
    Serial.println(second);
  }
  
  return result;
}

bool syncRTCWithGNSSLocal() {
  // Sync RTC with GNSS time adjusted to local timezone (CST/CDT)
  if (!isGNSSFixed || !validateGnssData()) {
    return false;
  }
  
  // Get time from GNSS (UTC)
  uint8_t hour = myGNSS.getHour();
  uint8_t minute = myGNSS.getMinute(); 
  uint8_t second = myGNSS.getSecond();
  uint8_t day = myGNSS.getDay();
  uint8_t month = myGNSS.getMonth();
  uint16_t year = myGNSS.getYear();
  
  // Apply timezone offset
  // currentTimeZone is in quarter hours, so divide by 4 to get hours
  int8_t timezoneHours = currentTimeZone / 4;
  
  // Convert to minutes for calculation
  int totalMinutes = hour * 60 + minute + (timezoneHours * 60);
  
  // Handle day rollover
  if (totalMinutes < 0) {
    totalMinutes += 24 * 60; // Add 24 hours
    day--; // Previous day
    if (day == 0) {
      // Handle month rollover
      month--;
      if (month == 0) {
        month = 12;
        year--;
      }
      // Set to last day of previous month (simplified)
      day = 31; // Will be corrected by RTC library
    }
  } else if (totalMinutes >= 24 * 60) {
    totalMinutes -= 24 * 60; // Subtract 24 hours
    day++; // Next day
    if (day > 31) { // Simplified day check
      day = 1;
      month++;
      if (month > 12) {
        month = 1;
        year++;
      }
    }
  }
  
  // Convert back to hours and minutes
  hour = totalMinutes / 60;
  minute = totalMinutes % 60;
  
  // Set RTC time with local timezone adjustment
  bool result = rtc.setTime(second, minute, hour, 1, day, month, year); // 1 = Sunday (placeholder)
  
  if (result) {
    Serial.print(F("RTC synced to GNSS Local Time ("));
    if (currentTimeZone == -24) {
      Serial.print(F("CST"));
    } else if (currentTimeZone == -20) {
      Serial.print(F("CDT"));
    } else {
      Serial.print(F("UTC"));
      Serial.print(timezoneHours >= 0 ? "+" : "");
      Serial.print(timezoneHours);
    }
    Serial.print(F("): "));
    Serial.print(year); Serial.print(F("/"));
    Serial.print(month); Serial.print(F("/"));
    Serial.print(day); Serial.print(F(" "));
    if (hour < 10) Serial.print(F("0"));
    Serial.print(hour); Serial.print(F(":"));
    if (minute < 10) Serial.print(F("0"));
    Serial.print(minute); Serial.print(F(":"));
    if (second < 10) Serial.print(F("0"));
    Serial.println(second);
  }
  
  return result;
}

void checkPeriodicGNSSTimeSync() {
  Serial.print(F("Performing periodic GNSS time sync..."));
  
  if (syncRTCWithGNSSLocal()) {
    Serial.println(F(" Success!"));
    lastGnssTimeSync = millis();
  } else {
    Serial.println(F(" Failed (no GPS fix)"));
    // Don't update lastGnssTimeSync on failure - will retry next interval
  }
}